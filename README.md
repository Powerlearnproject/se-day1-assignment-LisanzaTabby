[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18372083&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is a branch of computer science focused on the development, testing, and maintenance of software.

Reliability – Ensures that software functions as expected without errors or bias, which is especially crucial for critical applications like healthcare and finance.
Efficiency – Optimizes the developer's workflow while maintaining high-quality standards.
Scalability and Flexibility – Ensures that the system can accommodate increased workloads without compromising performance.
Security – Implements protective measures such as authentication, authorization, and encryption to safeguard user information.

Identify and describe at least three key milestones in the evolution of software engineering.  

Key Milestones in the Evolution of Software Engineering: 
1. The 1968 NATO Conference & the Rise of Structured Programming (1960s-1970s)- The 1968 NATO Conference on Software Engineering marked the birth of software engineering as a formal discipline. It addressed the software crisis, highlighting challenges like cost overruns, unreliable software, and poor project management. The conference emphasized the need for structured development methodologies to improve software reliability.
In response, the structured programming paradigm emerged in the 1970s. Advocated by Edsger Dijkstra, it introduced concepts such as modular design, loops, and functions, making software development more organized, readable, and maintainable. This shift helped eliminate unmanageable "spaghetti code" and laid the foundation for modern software engineering practices.
2. The Rise of Object-Oriented Programming (OOP) (1980s-1990s)- OOP became a dominant paradigm with languages like C++, Java, and Python. It introduced key principles such as encapsulation, inheritance, and polymorphism, making software more modular, reusable, and scalable. This shift significantly improved large-scale software development.
3. The Agile Revolution & DevOps (2000s - Present)- The Agile Manifesto (2001) transformed software development by promoting flexibility, iterative development, and customer collaboration. Agile methodologies like Scrum and Kanban replaced rigid, document-heavy approaches like Waterfall, leading to faster and more adaptive software development.
Later, the rise of DevOps (Development + Operations) further revolutionized the industry. Practices like Continuous Integration (CI) and Continuous Deployment (CD) automated the software release process, improving reliability and efficiency in modern software engineering

List and briefly explain the phases of the Software Development Life Cycle.

Planning – Defines project scope, feasibility, budget, and risks.
Requirement Analysis – Gathers and documents functional and non-functional requirements.
Design – Creates system architecture, database structure, and UI design.
Implementation (Coding) – Developers write and build the software.
Testing – Identifies and fixes bugs through various testing methods.
Deployment – Releases the software to users.
Maintenance & Support – Updates, fixes issues, and ensures long-term performance.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The Waterfall methodology follows a sequential, step-by-step approach where each phase—Requirements, Design, Implementation, Testing, and Deployment—must be completed before moving to the next. It is rigid, making changes difficult once development has started. Customer involvement is minimal, typically limited to the initial requirement-gathering phase. The final product is delivered only at the end of development, making it best suited for well-defined and stable projects such as medical software or government systems that require strict documentation and predictability. Testing in Waterfall occurs after coding is complete, which can make fixing issues more time-consuming.

In contrast, the Agile methodology is iterative and flexible, allowing for frequent changes and continuous improvement. Development occurs in short cycles (sprints/iterations), with each cycle producing a working version of the software. Agile encourages high customer involvement, ensuring feedback is incorporated throughout the process. Testing is performed continuously to catch and fix bugs early. This approach is ideal for dynamic projects with evolving requirements, such as mobile app development or startups looking to quickly adapt to user needs.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1. Software Developer- Writes, tests, and maintains code. Also Translates requirements into functional software.
2. Quality Assurance (QA) Engineer- Develops test plans and automated/manual test cases. Also Identifies and reports bugs, ensuring software quality.
3. Project Manager (PM)- Plans, coordinates, and oversees project execution. Also Manages timelines, budgets, and resources.



Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

- IDEs are software packages that offer a variety of tools for authoring, debugging, and testing code. Examples of these include Visual Studio, Eclipse, and IntelliJ IDEA.
- Version Control Systems (VCS): Software programs (such as Git and Subversion) for monitoring source code changes and organising teamwork.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

- Changing Requirements: As the project progresses, requirements may alter, causing scope creep and delays.
- Tight Deadlines: Rushing development and sacrificing quality might be the result of pressure to produce software solutions on time.
- Technical debt, which can hinder future development efforts and raise maintenance costs, is accumulated by short cuts or less-than-ideal solutions.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
- Unit testing is the process of testing separate software units or components.
      -> It guarantees that every unit, separate from other components, carries out its intended function as intended.
- Testing how various parts or subsystems interact with one another is known as integration testing.
      -> It assists in making sure interfaces function as intended and data moves across modules without hiccups.
- System testing is the process of evaluating the software system as a whole.
      ->It aids in confirming that the system satisfies all functional and non-functional needs, such as security, usability, and performance.
- Acceptance Testing: Verifying that the program satisfies user demands by comparing it to user specifications.
      -> It's important as it helps access if the program is prepared for deployment and satisfies end-user requirements.



#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering involves creating and refining input prompts to help AI models—like ChatGPT—produce precise, pertinent, and superior responses. In order for the AI to comprehend context, intent, and intended response, questions must be structured in a certain way.

Importance Of Interacting with AI models :

1. Prompt engineering improves response accuracy and is crucial in AI interaction. When prompts are well-designed, they reduce ambiguity and enable AI models to offer more accurate and helpful responses.
2. It increases efficiency by reducing the need for repeated changes, which saves time and effort in getting the intended answers.
3. Regulates Output Format and Style: Prompt engineering guarantees that responses meet user requirements by defining parameters like tone, structure, or duration (e.g., formal vs. conversational).


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

A Vague Prompt Example: "Tell me about technology."

Improved Prompt: "Explain how artificial intelligence is transforming the entertainment industry, with examples of its applications in improving entertainment."

Importance of better prompt:
- More Specific: Rather of covering a wide range of subjects like "technology," it concentrates on AI in healthcare.
- Clear Intent: Rather of requesting an open-ended conversation, it requests an explanation.
- Defined Scope: It eliminates superfluous details and focusses only on diagnosis and therapy.
